<!DOCTYPE html>

<html lang="zh-CN">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Magical Christmas Tree - Classic Edition</title>

    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">

    <style>

        :root {

            --pink-glow: #ffdae0;

            --accent-pink: #FF69B4;

            --gold: #D4AF37;

        }



        body, html {

            margin: 0;

            padding: 0;

            width: 100%;

            height: 100%;

            overflow: hidden;

            background: radial-gradient(circle at center, #2b002b 0%, #000000 100%);

            color: white;

            font-family: 'Cinzel', serif;

        }



        #loading-overlay {

            position: fixed;

            top: 0; left: 0; width: 100%; height: 100%;

            background: black;

            display: flex;

            flex-direction: column;

            justify-content: center;

            align-items: center;

            z-index: 1000;

            transition: opacity 1s ease;

        }



        .spinner {

            width: 50px;

            height: 50px;

            border: 3px solid rgba(255, 105, 180, 0.3);

            border-top-color: var(--accent-pink);

            border-radius: 50%;

            animation: spin 1s linear infinite;

            margin-bottom: 20px;

        }



        @keyframes spin { to { transform: rotate(360deg); } }



        #canvas-container {

            position: absolute;

            top: 0; left: 0; width: 100%; height: 100%;

        }



        header {

            position: absolute;

            top: 5%;

            left: 50%;

            transform: translateX(-50%);

            text-align: center;

            pointer-events: none;

            z-index: 10;

        }



        header h1 {

            font-family: 'Great Vibes', cursive;

            font-size: 4rem;

            margin: 0;

            color: var(--pink-glow);

            text-shadow: 0 0 20px rgba(255, 182, 193, 0.8), 0 0 40px rgba(255, 105, 180, 0.4);

        }



        /* Camera Feed */

        #camera-container {

            position: absolute;

            bottom: 20px;

            left: 20px;

            width: 200px;

            aspect-ratio: 4/3;

            border: 2px solid var(--accent-pink);

            border-radius: 12px;

            overflow: hidden;

            background: rgba(0, 0, 0, 0.5);

            box-shadow: 0 0 15px rgba(255, 105, 180, 0.3);

            z-index: 20;

        }



        #video-feed {

            width: 100%;

            height: 100%;

            object-fit: cover;

            transform: scaleX(-1);

        }



        /* Sidebar UI */

        #gesture-sidebar {

            position: absolute;

            top: 50%;

            right: 20px;

            transform: translateY(-50%);

            background: rgba(0, 0, 0, 0.6);

            backdrop-filter: blur(10px);

            padding: 20px;

            border-radius: 15px;

            border: 1px solid rgba(255, 255, 255, 0.1);

            z-index: 20;

            width: 180px;

        }



        /* Photo Manager Sidebar */

        #photo-manager {

            position: absolute;

            top: 50%;

            left: 20px;

            transform: translateY(-50%);

            background: rgba(0, 0, 0, 0.6);

            backdrop-filter: blur(10px);

            padding: 15px;

            border-radius: 15px;

            border: 1px solid rgba(255, 255, 255, 0.1);

            z-index: 20;

            width: 120px;

            max-height: 60vh;

            overflow-y: auto;

            display: none;

        }



        #photo-manager h3 {

            font-size: 0.8rem;

            text-align: center;

            margin-top: 0;

            color: var(--gold);

        }



        .photo-thumb-container {

            position: relative;

            margin-bottom: 10px;

            width: 100%;

            aspect-ratio: 1;

            border-radius: 8px;

            overflow: hidden;

            border: 1px solid rgba(255,255,255,0.2);

        }



        .photo-thumb {

            width: 100%;

            height: 100%;

            object-fit: cover;

        }



        .delete-btn {

            position: absolute;

            top: 2px;

            right: 2px;

            background: rgba(255, 0, 0, 0.7);

            color: white;

            border: none;

            border-radius: 50%;

            width: 20px;

            height: 20px;

            font-size: 12px;

            cursor: pointer;

            display: flex;

            align-items: center;

            justify-content: center;

        }



        .gesture-item {

            margin-bottom: 15px;

            opacity: 0.5;

            transition: all 0.3s ease;

            display: flex;

            flex-direction: column;

            align-items: center;

            text-align: center;

        }



        .gesture-item.active {

            opacity: 1;

            transform: scale(1.1);

            color: var(--accent-pink);

            text-shadow: 0 0 10px var(--accent-pink);

        }



        .gesture-icon { font-size: 1.5rem; margin-bottom: 5px; }

        .gesture-label { font-size: 0.8rem; font-weight: bold; }



        /* Controls */

        #controls {

            position: absolute;

            bottom: 30px;

            left: 50%;

            transform: translateX(-50%);

            display: flex;

            align-items: center;

            gap: 20px;

            z-index: 30;

        }



        .btn {

            background: rgba(255, 255, 255, 0.15);

            backdrop-filter: blur(5px);

            border: 1px solid rgba(255, 255, 255, 0.3);

            color: white;

            cursor: pointer;

            transition: all 0.2s;

            display: flex;

            align-items: center;

            justify-content: center;

            font-family: 'Cinzel', serif;

        }



        .btn:hover {

            background: var(--accent-pink);

            border-color: white;

        }



        #upload-btn {

            padding: 10px 25px;

            border-radius: 30px;

            font-size: 0.9rem;

            gap: 10px;

        }



        #music-btn {

            width: 50px;

            height: 50px;

            border-radius: 50%;

            font-size: 1.2rem;

        }



        input[type="file"] { display: none; }

    </style>

</head>

<body>



    <div id="loading-overlay">

        <div class="spinner"></div>

        <p>Ê≠£Âú®ËΩΩÂÖ•È≠îÊ≥ï...</p>

    </div>



    <header>

        <h1>Merry Christmas</h1>

    </header>



    <div id="canvas-container"></div>



    <div id="camera-container">

        <video id="video-feed" autoplay playsinline></video>

    </div>



    <div id="photo-manager">

        <h3>ÁÆ°ÁêÜÁÖßÁâá</h3>

        <div id="photo-list"></div>

    </div>



    <div id="gesture-sidebar">

        <div id="gst-fist" class="gesture-item active">

            <span class="gesture-icon">‚úä</span>

            <span class="gesture-label">Êè°Êã≥: ËÅöÂêàÊ†ë</span>

        </div>

        <div id="gst-open" class="gesture-item">

            <span class="gesture-icon">‚úã</span>

            <span class="gesture-label">Âº†ÂºÄ: Êï£ÂºÄ</span>

        </div>

        <div id="gst-pinch" class="gesture-item">

            <span class="gesture-icon">üëå</span>

            <span class="gesture-label">ÊçèÂêà: ËÅöÁÑ¶ÂõûÂøÜ</span>

        </div>

    </div>



    <div id="controls">

        <label for="file-input" id="upload-btn" class="btn">

            <span>üñºÔ∏è</span> ‰∏ä‰º†ÂõûÂøÜ

        </label>

        <input type="file" id="file-input" accept="image/*" multiple>

        

        <button id="music-btn" class="btn">üéµ</button>

    </div>



    <script type="importmap">

    {

        "imports": {

            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",

            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"

        }

    }

    </script>



    <script type="module">

        import * as THREE from 'three';

        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';

        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';



        // --- 1. Audio Synthesizer: Original Christmas Jingle Melody ---

        class ChristmasSynth {

            constructor() {

                this.ctx = null;

                this.isPlaying = false;

                // Original energetic jingle melody

                this.notes = [

                    { f: 392, d: 0.4 }, { f: 523, d: 0.4 }, { f: 523, d: 0.2 }, { f: 587, d: 0.2 }, { f: 523, d: 0.2 }, { f: 493, d: 0.2 }, { f: 440, d: 0.4 }, { f: 440, d: 0.4 },

                    { f: 440, d: 0.4 }, { f: 587, d: 0.4 }, { f: 587, d: 0.2 }, { f: 659, d: 0.2 }, { f: 587, d: 0.2 }, { f: 523, d: 0.2 }, { f: 493, d: 0.4 }, { f: 392, d: 0.4 },

                    { f: 392, d: 0.4 }, { f: 659, d: 0.4 }, { f: 659, d: 0.2 }, { f: 698, d: 0.2 }, { f: 659, d: 0.2 }, { f: 587, d: 0.2 }, { f: 523, d: 0.4 }, { f: 440, d: 0.4 },

                    { f: 392, d: 0.2 }, { f: 392, d: 0.2 }, { f: 440, d: 0.4 }, { f: 587, d: 0.4 }, { f: 493, d: 0.4 }, { f: 523, d: 0.8 }

                ];

                this.currentNote = 0;

            }



            init() {

                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();

            }



            playNext() {

                if (!this.isPlaying) return;

                const note = this.notes[this.currentNote];

                const osc = this.ctx.createOscillator();

                const gain = this.ctx.createGain();



                osc.type = 'triangle';

                osc.frequency.setValueAtTime(note.f, this.ctx.currentTime);

                

                gain.gain.setValueAtTime(0.08, this.ctx.currentTime);

                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + note.d);



                osc.connect(gain);

                gain.connect(this.ctx.destination);



                osc.start();

                osc.stop(this.ctx.currentTime + note.d);



                this.currentNote = (this.currentNote + 1) % this.notes.length;

                this.timeout = setTimeout(() => this.playNext(), note.d * 1000);

            }



            toggle() {

                this.init();

                this.isPlaying = !this.isPlaying;

                if (this.isPlaying) {

                    if (this.ctx.state === 'suspended') this.ctx.resume();

                    this.playNext();

                } else {

                    clearTimeout(this.timeout);

                }

                return this.isPlaying;

            }

        }



        const synth = new ChristmasSynth();



        // --- 2. MediaPipe Hand Tracking ---

        let handLandmarker;

        let video = document.getElementById('video-feed');

        let currentGesture = 'fist';



        async function initMediaPipe() {

            try {

                const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3');

                const filesetResolver = await vision.FilesetResolver.forVisionTasks(

                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"

                );

                

                handLandmarker = await vision.HandLandmarker.createFromOptions(filesetResolver, {

                    baseOptions: {

                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,

                        delegate: "GPU"

                    },

                    runningMode: "VIDEO",

                    numHands: 1

                });



                const stream = await navigator.mediaDevices.getUserMedia({ 

                    video: { width: 640, height: 480 } 

                });

                video.srcObject = stream;

                video.onloadeddata = () => predictWebcam();

            } catch (error) {

                console.error("MediaPipe Init Error:", error);

            }

        }



        let lastVideoTime = -1;

        function predictWebcam() {

            if (handLandmarker && video.currentTime !== lastVideoTime) {

                lastVideoTime = video.currentTime;

                const results = handLandmarker.detectForVideo(video, performance.now());

                if (results.landmarks && results.landmarks.length > 0) {

                    processGesture(results.landmarks[0]);

                } else {

                    updateGestureUI('fist'); 

                }

            }

            requestAnimationFrame(predictWebcam);

        }



        function processGesture(landmarks) {

            const thumbTip = landmarks[4];

            const indexTip = landmarks[8];

            const wrist = landmarks[0];

            const dPinch = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

            const isExtended = (tip) => Math.hypot(tip.x - wrist.x, tip.y - wrist.y) > 0.35;



            if (dPinch < 0.045) {

                updateGestureUI('pinch');

            } else if (isExtended(landmarks[8]) && isExtended(landmarks[12]) && isExtended(landmarks[16])) {

                updateGestureUI('open');

            } else {

                updateGestureUI('fist');

            }

        }



        function updateGestureUI(g) {

            if (currentGesture === g) return;

            currentGesture = g;

            document.querySelectorAll('.gesture-item').forEach(el => el.classList.remove('active'));

            const activeEl = document.getElementById(`gst-${g}`);

            if (activeEl) activeEl.classList.add('active');

        }



        // --- 3. Three.js Scene Setup ---

        let scene, camera, renderer, composer;

        let particles = [], phantomTree, snowflakes;

        let photos = [];

        let clock = new THREE.Clock();



        const PARTICLE_COUNT = 1000;

        const TREE_HEIGHT = 10;

        const TREE_RADIUS = 5;



        function initThree() {

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            camera.position.z = 15;



            renderer = new THREE.WebGLRenderer({ 

                antialias: true, 

                alpha: true,

                powerPreference: "high-performance"

            });

            renderer.setSize(window.innerWidth, window.innerHeight);

            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            document.getElementById('canvas-container').appendChild(renderer.domElement);



            const renderScene = new RenderPass(scene, camera);

            const bloomPass = new UnrealBloomPass(

                new THREE.Vector2(window.innerWidth, window.innerHeight), 

                0.8, 0.3, 0.9

            );

            

            composer = new EffectComposer(renderer);

            composer.addPass(renderScene);

            composer.addPass(bloomPass);

            composer.addPass(new OutputPass());



            createParticles();

            createSnow();

            

            window.addEventListener('resize', onWindowResize);

            

            setTimeout(() => {

                const loader = document.getElementById('loading-overlay');

                if (loader) {

                    loader.style.opacity = '0';

                    setTimeout(() => loader.remove(), 1000);

                }

            }, 1000);

            

            animate();

        }



        function createParticles() {

            const geo = new THREE.SphereGeometry(0.08, 6, 6);

            const matGold = new THREE.MeshStandardMaterial({ color: 0xD4AF37, emissive: 0xD4AF37, emissiveIntensity: 2 });

            const matPink = new THREE.MeshStandardMaterial({ color: 0xFF69B4, emissive: 0xFF69B4, emissiveIntensity: 2 });



            for (let i = 0; i < PARTICLE_COUNT; i++) {

                const mesh = new THREE.Mesh(geo, i % 2 === 0 ? matGold : matPink);

                const ratio = i / PARTICLE_COUNT;

                const angle = ratio * Math.PI * 24;

                const radius = (1 - ratio) * TREE_RADIUS;

                const x = Math.cos(angle) * radius;

                const y = ratio * TREE_HEIGHT - TREE_HEIGHT / 2;

                const z = Math.sin(angle) * radius;



                mesh.userData.treePos = new THREE.Vector3(x, y, z);

                mesh.userData.randPos = new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*30, (Math.random()-0.5)*20);

                mesh.position.copy(mesh.userData.treePos);

                scene.add(mesh);

                particles.push(mesh);

            }



            const phantomGeo = new THREE.SphereGeometry(0.04, 4, 4);

            const phantomMat = new THREE.MeshBasicMaterial({ color: 0xFF69B4, transparent: true, opacity: 0.25 });

            phantomTree = new THREE.InstancedMesh(phantomGeo, phantomMat, 800);

            const dummy = new THREE.Object3D();

            for(let i=0; i<800; i++) {

                const r = i/800;

                dummy.position.set(Math.cos(r*60)*(1-r)*4.3, r*10.5-5.25, Math.sin(r*60)*(1-r)*4.3);

                dummy.updateMatrix();

                phantomTree.setMatrixAt(i, dummy.matrix);

            }

            scene.add(phantomTree);

        }



        function createSnow() {

            const snowGeo = new THREE.BufferGeometry();

            const snowCount = 1500;

            const pos = new Float32Array(snowCount * 3);

            for(let i=0; i<snowCount*3; i++) pos[i] = (Math.random()-0.5) * 50;

            snowGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

            const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.6 });

            snowflakes = new THREE.Points(snowGeo, snowMat);

            scene.add(snowflakes);

        }



        function deletePhoto(id, mesh) {

            scene.remove(mesh);

            photos = photos.filter(p => p.uuid !== mesh.uuid);

            const element = document.getElementById(`thumb-${id}`);

            if (element) element.remove();

            if (photos.length === 0) document.getElementById('photo-manager').style.display = 'none';

        }



        document.getElementById('file-input').addEventListener('change', (e) => {

            const files = e.target.files;

            if (files.length > 0) document.getElementById('photo-manager').style.display = 'block';



            for (let file of files) {

                const url = URL.createObjectURL(file);

                const id = Math.random().toString(36).substr(2, 9);

                const photoList = document.getElementById('photo-list');

                const container = document.createElement('div');

                container.className = 'photo-thumb-container';

                container.id = `thumb-${id}`;

                container.innerHTML = `<img src="${url}" class="photo-thumb"><button class="delete-btn">√ó</button>`;

                photoList.appendChild(container);



                const loader = new THREE.TextureLoader();

                loader.load(url, (tex) => {

                    const aspect = tex.image.width / tex.image.height;

                    const geo = new THREE.PlaneGeometry(1.3 * aspect, 1.3);

                    const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent: true });

                    const mesh = new THREE.Mesh(geo, mat);

                    mesh.userData.treePos = new THREE.Vector3((Math.random()-0.5)*4.5, (Math.random()-0.5)*8, (Math.random()-0.5)*4.5);

                    mesh.userData.randPos = new THREE.Vector3((Math.random()-0.5)*28, (Math.random()-0.5)*20, (Math.random()-0.5)*15);

                    mesh.position.copy(mesh.userData.treePos);

                    scene.add(mesh);

                    photos.push(mesh);

                    container.querySelector('.delete-btn').addEventListener('click', () => {

                        deletePhoto(id, mesh);

                        URL.revokeObjectURL(url);

                    });

                });

            }

        });



        function animate() {

            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();



            const snowPos = snowflakes.geometry.attributes.position.array;

            for(let i=1; i<snowPos.length; i+=3) {

                snowPos[i] -= 0.05;

                if(snowPos[i] < -25) snowPos[i] = 25;

            }

            snowflakes.geometry.attributes.position.needsUpdate = true;



            particles.forEach(p => {

                const target = (currentGesture === 'fist' || currentGesture === 'pinch') ? p.userData.treePos : p.userData.randPos;

                p.position.lerp(target, 0.07);

            });



            let focusedPhoto = null;

            if(currentGesture === 'pinch' && photos.length > 0) {

                let minDist = Infinity;

                photos.forEach(p => {

                    const screenPos = p.position.clone().project(camera);

                    const dist = Math.hypot(screenPos.x, screenPos.y);

                    if(dist < minDist) { minDist = dist; focusedPhoto = p; }

                });

            }



            photos.forEach(p => {

                if(p === focusedPhoto) {

                    const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);

                    const targetPos = camera.position.clone().add(camDir.multiplyScalar(6.5));

                    p.position.lerp(targetPos, 0.15);

                    p.lookAt(camera.position);

                } else {

                    const target = currentGesture === 'open' ? p.userData.randPos : p.userData.treePos;

                    p.position.lerp(target, 0.06);

                    p.lookAt(p.position.clone().add(new THREE.Vector3(0,0,1))); 

                }

            });



            phantomTree.rotation.y += 0.007;

            composer.render();

        }



        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            composer.setSize(window.innerWidth, window.innerHeight);

        }



        document.getElementById('music-btn').addEventListener('click', (e) => {

            const active = synth.toggle();

            e.target.innerText = active ? '‚è∏Ô∏è' : 'üéµ';

        });



        initThree();

        initMediaPipe();

    </script>

</body>

</html>
