<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Christmas Tree - Custom Music Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --pink-glow: #ffdae0;
            --accent-pink: #FF69B4;
            --gold: #D4AF37;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: radial-gradient(circle at center, #2b002b 0%, #000000 100%);
            color: white;
            font-family: 'Cinzel', serif;
        }

        #loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 105, 180, 0.3);
            border-top-color: var(--accent-pink);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
        }

        header {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        header h1 {
            font-family: 'Great Vibes', cursive;
            font-size: 4rem;
            margin: 0;
            color: var(--pink-glow);
            text-shadow: 0 0 20px rgba(255, 182, 193, 0.8), 0 0 40px rgba(255, 105, 180, 0.4);
        }

        #camera-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            aspect-ratio: 4/3;
            border: 2px solid var(--accent-pink);
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.3);
            z-index: 20;
        }

        #video-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #gesture-sidebar {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 20;
            width: 180px;
        }

        #photo-manager {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 20;
            width: 120px;
            max-height: 60vh;
            overflow-y: auto;
            display: none;
        }

        #photo-manager h3 {
            font-size: 0.8rem;
            text-align: center;
            margin-top: 0;
            color: var(--gold);
        }

        .photo-thumb-container {
            position: relative;
            margin-bottom: 10px;
            width: 100%;
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .photo-thumb {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .delete-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(255, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .gesture-item {
            margin-bottom: 15px;
            opacity: 0.5;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .gesture-item.active {
            opacity: 1;
            transform: scale(1.1);
            color: var(--accent-pink);
            text-shadow: 0 0 10px var(--accent-pink);
        }

        .gesture-icon { font-size: 1.5rem; margin-bottom: 5px; }
        .gesture-label { font-size: 0.8rem; font-weight: bold; }

        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 30;
        }

        .btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Cinzel', serif;
            padding: 10px 18px;
            border-radius: 30px;
            font-size: 0.85rem;
            gap: 8px;
            white-space: nowrap;
        }

        .btn:hover {
            background: var(--accent-pink);
            border-color: white;
        }

        #music-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            padding: 0;
            font-size: 1.2rem;
        }

        input[type="file"] { display: none; }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <div class="spinner"></div>
        <p>Ê≠£Âú®ËΩΩÂÖ•Âú£ËØûÈ≠îÊ≥ï...</p>
    </div>

    <header>
        <h1>Merry Christmas</h1>
    </header>

    <div id="canvas-container"></div>

    <div id="camera-container">
        <video id="video-feed" autoplay playsinline></video>
    </div>

    <div id="photo-manager">
        <h3>ÁÆ°ÁêÜÁÖßÁâá</h3>
        <div id="photo-list"></div>
    </div>

    <div id="gesture-sidebar">
        <div id="gst-fist" class="gesture-item active">
            <span class="gesture-icon">‚úä</span>
            <span class="gesture-label">Êè°Êã≥: ËÅöÂêàÊ†ë</span>
        </div>
        <div id="gst-open" class="gesture-item">
            <span class="gesture-icon">‚úã</span>
            <span class="gesture-label">Âº†ÂºÄ: Êï£ÂºÄ</span>
        </div>
        <div id="gst-pinch" class="gesture-item">
            <span class="gesture-icon">üëå</span>
            <span class="gesture-label">ÊçèÂêà: ËÅöÁÑ¶ÂõûÂøÜ</span>
        </div>
    </div>

    <div id="controls">
        <label for="file-input" id="upload-btn" class="btn">
            <span>üñºÔ∏è</span> ‰∏ä‰º†ÁÖßÁâá
        </label>
        <input type="file" id="file-input" accept="image/*" multiple>

        <label for="music-input" id="music-upload-btn" class="btn">
            <span>üé∂</span> ÈÄâÊã©Èü≥‰πê
        </label>
        <input type="file" id="music-input" accept="audio/*">
        
        <button id="music-btn" class="btn">üéµ</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- 1. Custom Audio Player ---
        class CustomAudioPlayer {
            constructor() {
                this.audio = new Audio();
                this.audio.loop = true;
                this.isPlaying = false;
            }

            load(url) {
                this.audio.src = url;
                this.audio.load();
                if (this.isPlaying) this.audio.play();
            }

            toggle() {
                if (!this.audio.src) return false;
                this.isPlaying = !this.isPlaying;
                if (this.isPlaying) {
                    this.audio.play().catch(e => console.error("Play failed", e));
                } else {
                    this.audio.pause();
                }
                return this.isPlaying;
            }
        }

        const audioPlayer = new CustomAudioPlayer();

        // --- 2. MediaPipe Hand Tracking ---
        let handLandmarker;
        let video = document.getElementById('video-feed');
        let currentGesture = 'fist';

        async function initMediaPipe() {
            try {
                const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3');
                const filesetResolver = await vision.FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                handLandmarker = await vision.HandLandmarker.createFromOptions(filesetResolver, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                video.srcObject = stream;
                video.onloadeddata = () => predictWebcam();
            } catch (error) { console.error("MediaPipe Error:", error); }
        }

        let lastVideoTime = -1;
        function predictWebcam() {
            if (handLandmarker && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());
                if (results.landmarks && results.landmarks.length > 0) {
                    processGesture(results.landmarks[0]);
                } else { updateGestureUI('fist'); }
            }
            requestAnimationFrame(predictWebcam);
        }

        function processGesture(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const wrist = landmarks[0];
            const dPinch = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            const isExtended = (tip) => Math.hypot(tip.x - wrist.x, tip.y - wrist.y) > 0.35;
            if (dPinch < 0.045) { updateGestureUI('pinch'); }
            else if (isExtended(landmarks[8]) && isExtended(landmarks[12]) && isExtended(landmarks[16])) { updateGestureUI('open'); }
            else { updateGestureUI('fist'); }
        }

        function updateGestureUI(g) {
            if (currentGesture === g) return;
            currentGesture = g;
            document.querySelectorAll('.gesture-item').forEach(el => el.classList.remove('active'));
            const activeEl = document.getElementById(`gst-${g}`);
            if (activeEl) activeEl.classList.add('active');
        }

        // --- 3. Three.js Scene Setup ---
        let scene, camera, renderer, composer;
        let particles = [], phantomTree, snowflakes;
        let photos = [];
        let clock = new THREE.Clock();
        const PARTICLE_COUNT = 1000;
        const TREE_HEIGHT = 10;
        const TREE_RADIUS = 5;

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.3, 0.9);
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(new OutputPass());
            createParticles();
            createSnow();
            window.addEventListener('resize', onWindowResize);
            setTimeout(() => {
                const loader = document.getElementById('loading-overlay');
                if (loader) { loader.style.opacity = '0'; setTimeout(() => loader.remove(), 1000); }
            }, 1000);
            animate();
        }

        function createParticles() {
            const geo = new THREE.SphereGeometry(0.08, 6, 6);
            const matGold = new THREE.MeshStandardMaterial({ color: 0xD4AF37, emissive: 0xD4AF37, emissiveIntensity: 2 });
            const matPink = new THREE.MeshStandardMaterial({ color: 0xFF69B4, emissive: 0xFF69B4, emissiveIntensity: 2 });
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const mesh = new THREE.Mesh(geo, i % 2 === 0 ? matGold : matPink);
                const ratio = i / PARTICLE_COUNT;
                const angle = ratio * Math.PI * 24;
                const radius = (1 - ratio) * TREE_RADIUS;
                mesh.userData.treePos = new THREE.Vector3(Math.cos(angle) * radius, ratio * TREE_HEIGHT - TREE_HEIGHT / 2, Math.sin(angle) * radius);
                mesh.userData.randPos = new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*30, (Math.random()-0.5)*20);
                mesh.position.copy(mesh.userData.treePos);
                scene.add(mesh);
                particles.push(mesh);
            }
            const phantomGeo = new THREE.SphereGeometry(0.04, 4, 4);
            const phantomMat = new THREE.MeshBasicMaterial({ color: 0xFF69B4, transparent: true, opacity: 0.25 });
            phantomTree = new THREE.InstancedMesh(phantomGeo, phantomMat, 800);
            const dummy = new THREE.Object3D();
            for(let i=0; i<800; i++) {
                const r = i/800;
                dummy.position.set(Math.cos(r*60)*(1-r)*4.3, r*10.5-5.25, Math.sin(r*60)*(1-r)*4.3);
                dummy.updateMatrix();
                phantomTree.setMatrixAt(i, dummy.matrix);
            }
            scene.add(phantomTree);
        }

        function createSnow() {
            const snowGeo = new THREE.BufferGeometry();
            const snowCount = 1500;
            const pos = new Float32Array(snowCount * 3);
            for(let i=0; i<snowCount*3; i++) pos[i] = (Math.random()-0.5) * 50;
            snowGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            snowflakes = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.6 }));
            scene.add(snowflakes);
        }

        function deletePhoto(id, mesh) {
            scene.remove(mesh);
            photos = photos.filter(p => p.uuid !== mesh.uuid);
            document.getElementById(`thumb-${id}`)?.remove();
            if (photos.length === 0) document.getElementById('photo-manager').style.display = 'none';
        }

        // Photo Upload Handling
        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if (files.length > 0) document.getElementById('photo-manager').style.display = 'block';
            for (let file of files) {
                const url = URL.createObjectURL(file);
                const id = Math.random().toString(36).substr(2, 9);
                const container = document.createElement('div');
                container.className = 'photo-thumb-container';
                container.id = `thumb-${id}`;
                container.innerHTML = `<img src="${url}" class="photo-thumb"><button class="delete-btn">√ó</button>`;
                document.getElementById('photo-list').appendChild(container);
                new THREE.TextureLoader().load(url, (tex) => {
                    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.3 * (tex.image.width / tex.image.height), 1.3), new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent: true }));
                    mesh.userData.treePos = new THREE.Vector3((Math.random()-0.5)*4.5, (Math.random()-0.5)*8, (Math.random()-0.5)*4.5);
                    mesh.userData.randPos = new THREE.Vector3((Math.random()-0.5)*28, (Math.random()-0.5)*20, (Math.random()-0.5)*15);
                    mesh.position.copy(mesh.userData.treePos);
                    scene.add(mesh);
                    photos.push(mesh);
                    container.querySelector('.delete-btn').addEventListener('click', () => { deletePhoto(id, mesh); URL.revokeObjectURL(url); });
                });
            }
        });

        // Music Upload Handling
        document.getElementById('music-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                audioPlayer.load(url);
                // Auto play or show active UI
                document.getElementById('music-btn').innerText = '‚è∏Ô∏è';
                if (!audioPlayer.isPlaying) audioPlayer.toggle();
            }
        });

        document.getElementById('music-btn').addEventListener('click', (e) => {
            const active = audioPlayer.toggle();
            e.target.innerText = active ? '‚è∏Ô∏è' : 'üéµ';
        });

        function animate() {
            requestAnimationFrame(animate);
            const snowPos = snowflakes.geometry.attributes.position.array;
            for(let i=1; i<snowPos.length; i+=3) { snowPos[i] -= 0.05; if(snowPos[i] < -25) snowPos[i] = 25; }
            snowflakes.geometry.attributes.position.needsUpdate = true;
            particles.forEach(p => { p.position.lerp((currentGesture === 'fist' || currentGesture === 'pinch') ? p.userData.treePos : p.userData.randPos, 0.07); });
            let focusedPhoto = null;
            if(currentGesture === 'pinch' && photos.length > 0) {
                let minDist = Infinity;
                photos.forEach(p => { const sPos = p.position.clone().project(camera); const d = Math.hypot(sPos.x, sPos.y); if(d < minDist) { minDist = d; focusedPhoto = p; } });
            }
            photos.forEach(p => {
                if(p === focusedPhoto) { p.position.lerp(camera.position.clone().add(new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).multiplyScalar(6.5)), 0.15); p.lookAt(camera.position); }
                else { p.position.lerp(currentGesture === 'open' ? p.userData.randPos : p.userData.treePos, 0.06); p.lookAt(p.position.clone().add(new THREE.Vector3(0,0,1))); }
            });
            phantomTree.rotation.y += 0.007;
            composer.render();
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }
        initThree();
        initMediaPipe();
    </script>
</body>
</html>
